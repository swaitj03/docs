---
title: "Third Party Documentation"
---

# Technology Stack Rationale

## Frontend Framework - React

**Technology**: React.js  
**Rationale**: We chose React for our web application frontend because it allows us to create a highly performant application with excellent user experience. Additionally, React provides the foundation for future mobile app development using React Native, enabling us to share code and development expertise across web and mobile platforms. This approach maximizes our development efficiency and ensures consistency across all user interfaces.

## Email Service - Gmail API

**Technology**: Gmail API Service  
**Rationale**: We integrated Gmail's email API service for our driver notifications and marketing email campaigns. Gmail API was selected due to its simplicity and ease of implementation. The straightforward integration process allows us to quickly send automated notifications to drivers when they are approved by admins, as well as manage our marketing email communications efficiently. The reliability and widespread adoption of Gmail ensures high deliverability rates for our communications.

## Testing Frameworks

**Technologies**: Jest (Frontend) and Pytest (Backend)  
**Rationale**: 
- **Jest**: Selected for frontend testing because our development team has extensive experience with Jest, allowing us to implement comprehensive testing quickly and effectively.
- **Pytest**: Chosen for backend testing due to its simplicity and ease of learning. The straightforward syntax and powerful features make it accessible for our team to write and maintain robust test suites for our API endpoints.

## UI Notifications

**Technology:** `react-hot-toast` (or similar toast library)  
**Purpose:** Provides user feedback for common actions such as successful logins, order completion, and network or API errors.

**Example Usage:**
```typescript
import { toast } from "react-hot-toast";

toast.success("Order completed successfully!");
toast.error("Failed to fetch data. Please try again.");
```

**Rationale:**  
Using non-blocking toast notifications helps improve user experience by immediately confirming actions or alerting users to issues without interrupting their workflow.  
It replaces intrusive modal popups and keeps the interface smooth and responsive.


## Backend Framework - FastAPI

**Technology**: FastAPI  
**Rationale**: We selected FastAPI for our backend API development because our team has significant experience with this framework, enabling rapid development and deployment. Additionally, FastAPI's architecture and performance characteristics make it ideal for future scaling using Kubernetes. The framework's built-in support for async operations, automatic API documentation generation, and excellent performance make it well-suited for handling the demands of a food delivery platform that may need to scale horizontally in the future.

---

# External API
## Other groups API used

Our third party API gets email address from our external group and sends marketing emails to them in order to promote WitsEats

For Authentication: an API_key is needed in the request header which will be stored as an environment variable. Without this, any request will be rejected as Unauthorised.

### Base URL: https://tutorcore.works/api/external

### GET: /api/emails

Response 200 (If success) 
```json
{
    "emails":[
        "john@doe.com",
        "james.white@gmail.com"
    ]
}
```

Response 401 (Unauthorised)
```json
{
    "detail": "Could not validate credentials + [provided_api_key]"
}
```

Response 500 (Internal Server Error)
```json
{
 "detail": "Eish, our supabase service key incorrect"
}
```

---
## Other external API's Used
### Supabase Auth (Authentication Service)

- **Purpose**: Provides user signup, login, and JWT authentication.  
- **Base URL**: `https://mgxzqglnhoxyhszmwrff.supabase.co/auth/v1`  
- **Authentication**:  
  - No authentication required for `signup` and `token?grant_type=password`.  
  - JWT required for all protected routes.  

#### Example Request (Login)
```http
POST /token?grant_type=password
Content-Type: application/json

{
  "email": "jane@example.com",
  "password": "mypassword"
}
```

#### Example Response
```json
{
  "access_token": "jwt...",
  "expires_in": 3600,
  "refresh_token": "..."
}
```

### HTML5 Geolocation API (Browser API)

- **Purpose**: Obtains the user‚Äôs current latitude and longitude.  
- **Usage**:
```javascript
navigator.geolocation.getCurrentPosition(successCallback, errorCallback, {
  enableHighAccuracy: true,
  timeout: 10000,
  maximumAge: 5000
});
```
- **Authentication**: None (user must allow browser location permission).  

#### Example Response
```json
{
  "coords": {
    "latitude": -26.1918,
    "longitude": 28.0276,
    "accuracy": 12.5
  }
}
```


### OpenStreetMap Embed (Map Display when receiving map input)

- **Purpose**: Displays a map centered on the user‚Äôs location.  
- **Usage**:
```html
<iframe
  src="https://www.openstreetmap.org/export/embed.html?bbox=28.022%2C-26.197%2C28.033%2C-26.187&layer=mapnik&marker=-26.1918%2C28.0276"
  title="map"
></iframe>
```

- **Parameters**:  
  - `bbox` ‚Äì bounding box of the map viewport  
  - `marker` ‚Äì coordinates for the marker (lat, lon)  

- **Authentication**: None (public service).  
- **Response**: Visual map embed, no JSON output

### Leaflet (Interactive Map Display when displaying map)

**Technology:** `react-leaflet` with the Leaflet JS library  
**Purpose:** Displays an interactive map showing order locations.  
Unlike the static OpenStreetMap embed, Leaflet allows real-time updates of map markers, zoom, and tooltips directly within the React UI.

**Implementation Example:**
```tsx
import { MapContainer, TileLayer, Marker, Popup, ZoomControl } from "react-leaflet";
import L from "leaflet";

const DefaultIcon = L.icon({
  iconUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png",
  shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
  iconSize: [30, 50],
  iconAnchor: [15, 50],
});
L.Marker.prototype.options.icon = DefaultIcon;

<MapContainer center={[lat, lon]} zoom={16} scrollWheelZoom={false} style={{ height: "200px" }}>
  <TileLayer url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png" />
  <Marker position={[lat, lon]}>
    <Popup>üìç {note || "Order location"}</Popup>
  </Marker>
  <ZoomControl position="bottomright" />
</MapContainer>
```

**Rationale:**  
Provides dynamic, zoomable map interaction for drivers and buyers.   
Leaflet is open-source, lightweight, and doesn‚Äôt require an API key, making it a reliable, privacy-friendly map rendering solution.

---


### Realtime Features (Supabase Realtime)

**Technology:** Supabase Realtime (WebSocket-based database event streaming)  
**Purpose:** Keeps order and chat data synchronized instantly between multiple drivers and buyers without requiring page reloads.

**Usage Examples:**

- **Driver Orders Management:**  
  - Supabase Realtime ensures that order availability stays consistent across all drivers:  
  - When a driver **accepts** an order, it is immediately removed from the **Available Orders** list for all other drivers through a realtime broadcast. This prevents multiple drivers from accepting the same order and keeps all screens synchronized in real time. 
- **Buyers Orders Management:** 
  - On the buyers side when a driver **accepts** an order, the cancel order button disappears and a chat button appears - this prevents the buyer from cancelling the order and the chat button enables the buyer and driver to begin their chat.  
  - Once the driver marks the order as **completed**, it appears under **Previous Orders** for buyers.  
  
- **Chat System (Buyer ‚Üî Driver):**  
  - Supabase Realtime is also used for messaging between buyers and drivers.  
  - Messages are delivered instantly, and each order chat shows an **unread message counter** that updates live.  
  - When a new message is received, a **toast notification** pops up (e.g., ‚ÄúYou received a new message from order #1234‚Äù) to alert the recipient even if the chat window is not open.

- **Toast Notifications:**  
  - Connected to the realtime message events.  
  - Triggered whenever a new chat message arrives to alert the user immediately, similar to mobile messaging apps.

**Implementation Example:**
```typescript
const channel = supabase
  .channel("orders-realtime")
  .on(
    "postgres_changes",
    {
      event: "*",
      schema: "public",
      table: "orders",
    },
    (payload) => {
      setOrders((prev) =>
        prev.map((o) => (o.id === payload.new.id ? payload.new : o))
      );
    }
  )
  .subscribe();
```

**Rationale:**  
Supabase Realtime uses WebSockets to detect and push changes in the database instantly to all connected users.  
This ensures that:  
- Orders are removed immediately from other drivers‚Äô ‚ÄúAvailable Orders‚Äù lists as soon as one driver accepts them.  
- Each driver‚Äôs order screens always reflect the current system state.  
- Chat messages and unread counters update live with toast pop-ups for new messages.  

This combination provides a fast, event-driven user experience where drivers, buyers, and messages all stay synchronized across the system.

## Geolocation and Geofencing

**Technologies Used:**
- **HTML5 Geolocation API** ‚Äì obtains user coordinates.  
- **OpenStreetMap / geojson.io** ‚Äì defines polygon boundaries for the delivery area.  
- **PostGIS (in Supabase)** ‚Äì performs spatial ‚Äúpoint-in-polygon‚Äù checks.  

**Purpose:**  
Restricts order placements and deliveries to within the valid university campus boundary.

**Process:**

1. **Define the delivery zone**  
   Use OpenStreetMap or [geojson.io](https://geojson.io) to draw the campus boundary and export coordinates.  
   Example:
   ```json
   [
     [28.03012, -26.19075],
     [28.03156, -26.19102],
     [28.03290, -26.19040],
     [28.03012, -26.19075]
   ]
   ```

2. **Store the polygon in the database**  
   ```sql
   INSERT INTO campus_zones (name, area)
   VALUES ('Wits Main Campus',
     ST_GeomFromText(
       'POLYGON((28.03012 -26.19075, 28.03156 -26.19102, 28.03290 -26.19040, 28.03012 -26.19075))',
       4326
     )
   );
   ```

3. **Capture user coordinates on the frontend**  
   ```javascript
   navigator.geolocation.getCurrentPosition(
     (pos) => sendToBackend(pos.coords.latitude, pos.coords.longitude),
     (err) => console.error(err),
     { enableHighAccuracy: true }
   );
   ```

4. **Validate the coordinates on the backend**  
   ```sql
   SELECT ST_Contains(area, ST_SetSRID(ST_MakePoint(:lon, :lat), 4326))
   FROM campus_zones
   WHERE name = 'Wits Main Campus';
   ```

5. **If outside campus**, the backend responds with:
   ```json
   { "allowed": false, "reason": "Outside campus" }
   ```

**Rationale:**  
Combining browser-based geolocation with backend spatial validation ensures all deliveries occur within the allowed area.  
It provides a robust geofencing mechanism that enforces business rules reliably.

---



# exposed public API endpoints

we allow other groups te get emails of our users for marketing purposes

## Authentication

**Authentication**: All requests must include a valid API key in the request header

**Header**: X_KEY: your-api-key

### GET /api/emails

Response 200 (Success)

```json
[
  {
    "id": "abc123",
    "email": "user@example.com",
    "subscribed": true
  },
  {
    "id": "def456",
    "email": "test@example.com",
    "subscribed":¬†false
¬†¬†}
]
```


Response 401 (Unauthorized)

```json
{
  "detail": "Could not validate credentials + <your-supplied-key>"
}
```

Response 500 (Internal Server¬†Error)

```json
{
  "detail": "Internal Server Error"
}
```

