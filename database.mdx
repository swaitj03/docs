---
title: "Database Documentation"
description: "Complete database documentation for WitsEats"
---

# Database Schema

This document describes the database schema for the restaurant management system, including table structures, relationships, and operational details.

## Overview

The schema uses PostgreSQL with UUID primary keys, automatic timestamp management, and PostGIS extension for spatial data handling.

## Schema Design Rationale

### Core Design Principles

**UUID Primary Keys**: All tables use UUIDs instead of auto-incrementing integers to prevent ID conflicts in distributed systems and provide better security by making internal IDs unpredictable.

**Dual Cart System**: The schema includes both `cart_items` (direct) and `carts` + `carts_items` (normalized) approaches to support different use cases:
- Direct approach allows multi-restaurant carts for comparison shopping
- Normalized approach enforces restaurant-specific carts for better order management

**Denormalized Order Data**: Order items store `menu_item_name` and `menu_item_price` as separate fields to preserve historical accuracy even when menu items are modified or deleted.

**Spatial Data Integration**: PostGIS geometry types enable location-based features like delivery zone management, distance calculations, and spatial queries for restaurant discovery.

**Role-Based Architecture**: The `user_role` enum and `driver_approvals` table support a multi-role system where users can be customers, drivers, or admins with appropriate approval workflows.

**Cascade vs Set-Null Deletes**: Strategic use of cascade deletes for dependent data (carts, orders) while using set-null for driver references to preserve order history when drivers are removed.

## PostGIS Extension

### Overview

The database uses the PostGIS extension, which is a massive add-on that teaches PostgreSQL how to handle spatial data including geometry, geography, and raster data types.

### PostGIS Installation

When you run:
```sql
create extension if not exists postgis;
```

PostgreSQL installs the PostGIS extension, which creates and maintains several system catalog tables inside your database.

### PostGIS System Tables

PostGIS creates the following system catalog tables that are used internally:

#### geometry_columns
- **Purpose**: Metadata about all geometry columns in your database
- **Usage**: PostGIS uses this to understand your geometry columns and their properties
- **Content**: Information about geometry column names, types, dimensions, and spatial reference systems

#### geography_columns  
- **Purpose**: Metadata about all geography columns in your database
- **Usage**: Similar to geometry_columns but for geography data types
- **Content**: Information about geography column properties and coordinate systems

#### spatial_ref_sys
- **Purpose**: Definitions of all spatial reference systems (SRIDs)
- **Usage**: Contains coordinate system definitions like EPSG:4326 (WGS84 lat/lon)
- **Content**: Authority names, SRID codes, and coordinate system transformations

#### raster_columns & raster_overviews
- **Purpose**: Metadata for raster data if raster support is enabled
- **Usage**: Information about raster data storage and processing
- **Content**: Raster column properties and overview pyramid information

### What PostGIS Does Under the Hood

PostGIS adds the following capabilities to PostgreSQL:

1. **New Data Types**:
   - `geometry` - For 2D/3D geometric data
   - `geography` - For geodetic (spherical) data
   - `raster` - For raster/imagery data

2. **New Functions**:
   - `ST_Distance()` - Calculate distances between geometries
   - `ST_Contains()` - Check if one geometry contains another
   - `ST_Transform()` - Transform between coordinate systems
   - Hundreds of other spatial functions

3. **System Catalog Tables**:
   - `geometry_columns` - Geometry column metadata
   - `geography_columns` - Geography column metadata  
   - `spatial_ref_sys` - Spatial reference system definitions
   - Raster tables (if raster support is enabled)

### Important Notes

- **Not Duplicates**: These system tables are NOT duplicates of your application tables like `campuses`
- **Global Metadata**: They are global metadata that PostGIS uses to understand your spatial data
- **Automatic Management**: PostGIS automatically manages these tables when you create spatial columns
- **Required for Spatial Operations**: These tables are essential for PostGIS to function properly

## Table Structure

### PostGIS Usage Summary

**Tables Using PostGIS:**
- **`campuses`**: Uses PostGIS `geometry` data type for campus boundaries
- **`spatial_ref_sys`**: PostGIS system table (not an application table)

**Tables NOT Using PostGIS:**
- **`restaurants`**: Uses text for location descriptions
- **`orders`**: Uses float coordinates (lat/lon) for delivery locations
- **All other tables**: Use standard PostgreSQL data types

**PostGIS System Tables (Automatically Created):**
- `geometry_columns`: Metadata about geometry columns
- `geography_columns`: Metadata about geography columns
- `spatial_ref_sys`: Spatial reference system definitions
- `raster_columns`, `raster_overviews`: Raster data metadata (if enabled)

### Users Table

The core table storing user information and authentication:

```sql
create table if not exists public.users (
  id uuid primary key references auth.users(id) on delete cascade,
  email text not null,
  first_name text not null,
  surname text not null,
  phone text not null,
  role user_role not null default 'customer',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
```

**Fields:**
- `id`: Unique identifier (UUID, references auth.users)
- `email`: User email address (required)
- `first_name`: User's first name (required)
- `surname`: User's surname (required)
- `phone`: User's phone number (required)
- `role`: User role (customer, driver, admin) - defaults to 'customer'
- `created_at`: Creation timestamp
- `updated_at`: Last update timestamp

**Relationships:**
- Links to external authentication system via `auth.users`
- Referenced by driver_approvals, carts, cart_items, and orders tables

### Driver Approvals Table

Manages driver approval workflow:

```sql
create table if not exists public.driver_approvals (
  user_id uuid primary key references public.users(id) on delete cascade,
  is_approved boolean not null default false,
  created_at timestamptz not null default now(),
  approved_at timestamptz
);
```

**Fields:**
- `user_id`: Foreign key to users table (primary key)
- `is_approved`: Approval status (defaults to false)
- `created_at`: Application timestamp
- `approved_at`: Approval timestamp (nullable)

**Constraints:**
- One approval record per user
- Cascade delete when user is removed

**Design Rationale**: Separate approval table allows for audit trail of driver applications and supports approval workflows without cluttering the main users table.

### Restaurants Table

The core table storing restaurant information:

```sql
create table if not exists public.restaurants (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  description text not null default '',
  location text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  image_url text
);
```

**Fields:**
- `id`: Unique identifier (UUID, auto-generated)
- `name`: Restaurant name (required)
- `description`: Restaurant description
- `location`: Restaurant location (text description)
- `created_at`: Creation timestamp
- `updated_at`: Last update timestamp
- `image_url`: Restaurant image URL (nullable)

**Design Rationale**: Text-based location field provides flexibility for various address formats while maintaining simplicity for basic location storage. Note: This table does NOT use PostGIS geometry types - it uses simple text for location descriptions. PostGIS geometry is used in the `campuses` table for spatial operations.

### Menus Table

Each restaurant has exactly one menu:

```sql
create table if not exists public.menus (
  id uuid primary key default gen_random_uuid(),
  restaurant_id uuid not null references public.restaurants(id) on delete cascade,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint menus_one_per_restaurant unique (restaurant_id)
);
```

**Fields:**
- `id`: Unique identifier (UUID, auto-generated)
- `restaurant_id`: Foreign key to restaurants table
- `created_at`: Creation timestamp
- `updated_at`: Last update timestamp

**Constraints:**
- One menu per restaurant (unique constraint on `restaurant_id`)
- Cascade delete when restaurant is removed

### Menu Items Table

Stores individual menu items:

```sql
create table if not exists public.menu_items (
  id uuid primary key default gen_random_uuid(),
  menu_id uuid not null references public.menus(id) on delete cascade,
  name text not null,
  description text not null default '',
  price numeric(10,2) not null default 0,
  category text not null default 'General',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
```

**Fields:**
- `id`: Unique identifier (UUID, auto-generated)
- `menu_id`: Foreign key to menus table
- `name`: Item name (required)
- `description`: Item description
- `price`: Item price (decimal with 2 decimal places)
- `category`: Item category (defaults to 'General')
- `created_at`: Creation timestamp
- `updated_at`: Last update timestamp

### Carts Table

Represents a user's shopping cart for a specific restaurant:

```sql
create table if not exists public.carts (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.users(id) on delete cascade,
  restaurant_id uuid not null references public.restaurants(id) on delete cascade,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
```

**Fields:**
- `id`: Unique identifier (UUID, auto-generated)
- `user_id`: Foreign key to users table
- `restaurant_id`: Foreign key to restaurants table
- `created_at`: Creation timestamp
- `updated_at`: Last update timestamp

**Constraints:**
- One cart per user per restaurant
- Cascade delete when user or restaurant is removed

### Cart Items Table (Direct)

Direct relationship between users and menu items:

```sql
create table if not exists public.cart_items (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.users(id) on delete cascade,
  menu_item_id uuid not null references public.menu_items(id) on delete cascade,
  quantity int4 not null default 1,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
```

**Fields:**
- `id`: Unique identifier (UUID, auto-generated)
- `user_id`: Foreign key to users table
- `menu_item_id`: Foreign key to menu_items table
- `quantity`: Item quantity (defaults to 1)
- `created_at`: Creation timestamp
- `updated_at`: Last update timestamp

### Carts Items Table (Normalized)

Normalized cart items through the carts table:

```sql
create table if not exists public.carts_items (
  id uuid primary key default gen_random_uuid(),
  cart_id uuid not null references public.carts(id) on delete cascade,
  menu_item_id uuid not null references public.menu_items(id) on delete cascade,
  quantity int4 not null default 1,
  notes text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
```

**Fields:**
- `id`: Unique identifier (UUID, auto-generated)
- `cart_id`: Foreign key to carts table
- `menu_item_id`: Foreign key to menu_items table
- `quantity`: Item quantity (defaults to 1)
- `notes`: Special instructions for the item (nullable)
- `created_at`: Creation timestamp
- `updated_at`: Last update timestamp

**Note:** The presence of both `cart_items` and `carts_items` suggests a potential schema evolution. The `carts_items` table with the `carts` table provides a more normalized structure.

**Design Rationale**: Dual cart system supports different business models - direct approach for multi-restaurant comparison shopping, normalized approach for restaurant-specific ordering with better data organization.

### Orders Table

Records customer orders with delivery information:

```sql
create table if not exists public.orders (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.users(id) on delete cascade,
  driver_id uuid references public.users(id) on delete set null,
  restaurant_id uuid not null references public.restaurants(id) on delete cascade,
  note text,
  status order_status not null default 'pending',
  subtotal numeric(10,2) not null default 0,
  delivery_fee numeric(10,2) not null default 0,
  total_price numeric(10,2) not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  lat float not null,
  lon float not null
);
```

**Fields:**
- `id`: Unique identifier (UUID, auto-generated)
- `user_id`: Foreign key to users table (customer)
- `driver_id`: Foreign key to users table (driver, nullable)
- `restaurant_id`: Foreign key to restaurants table
- `note`: Special delivery instructions (nullable)
- `status`: Order status (pending, accepted, preparing, delivering, completed, canceled)
- `subtotal`: Order subtotal before delivery fee
- `delivery_fee`: Delivery fee amount
- `total_price`: Total order amount including delivery fee
- `created_at`: Creation timestamp
- `updated_at`: Last update timestamp
- `lat`: Delivery location latitude (required, float)
- `lon`: Delivery location longitude (required, float)

**Design Rationale**: This table uses simple float coordinates (lat/lon) for delivery locations rather than PostGIS geometry types. This approach provides precise coordinate storage for distance calculations while maintaining simplicity. PostGIS geometry types are used in the `campuses` table for complex spatial operations and boundary management.

### Order Items Table

Details the specific menu items in each order:

```sql
create table if not exists public.order_items (
  id uuid primary key default gen_random_uuid(),
  order_id uuid not null references public.orders(id) on delete cascade,
  menu_item_id uuid not null references public.menu_items(id) on delete cascade,
  menu_item_name text not null,
  menu_item_price numeric(10,2) not null,
  quantity int4 not null default 1,
  notes text
);
```

**Fields:**
- `id`: Unique identifier (UUID, auto-generated)
- `order_id`: Foreign key to orders table
- `menu_item_id`: Foreign key to menu_items table
- `menu_item_name`: Denormalized item name (for historical accuracy)
- `menu_item_price`: Denormalized item price (for historical accuracy)
- `quantity`: Item quantity (defaults to 1)
- `notes`: Special instructions for the item (nullable)

**Note:** The `menu_item_name` and `menu_item_price` fields are denormalized to preserve order history even if menu items are later modified or deleted.

**Design Rationale**: Denormalization ensures order history remains accurate and complete even when restaurants update their menus, prices, or remove items. This is critical for customer service, accounting, and legal compliance.

### Messages Table

Handles communication between users regarding orders:

```sql
create table if not exists public.messages (
  id uuid primary key default gen_random_uuid(),
  order_id uuid not null references public.orders(id) on delete cascade,
  sender_id uuid not null references public.users(id) on delete cascade,
  content text not null,
  created_at timestamptz not null default now(),
  read_at timestamptz
);
```

**Fields:**
- `id`: Unique identifier (UUID, auto-generated)
- `order_id`: Foreign key to orders table
- `sender_id`: Foreign key to users table (who sent the message)
- `content`: Message content (required)
- `created_at`: Message creation timestamp
- `read_at`: Timestamp when message was read (nullable)

**Design Rationale**: Enables real-time communication between customers, drivers, and restaurant staff regarding specific orders, improving customer service and order management.

### Campuses Table

Stores campus information for delivery zones using PostGIS geometry:

```sql
create table if not exists public.campuses (
  id int4 primary key,
  name text not null,
  geom geometry not null,
  created_at timestamptz not null default now()
);
```

**Fields:**
- `id`: Unique identifier (integer)
- `name`: Campus name (required)
- `geom`: Campus geometry (PostGIS geometry type)
- `created_at`: Creation timestamp

**PostGIS Integration:**
- Uses PostGIS `geometry` data type for storing campus boundaries (this is the ONLY table using PostGIS geometry)
- Automatically registered in PostGIS `geometry_columns` system table when created
- Enables spatial queries like "find restaurants within campus boundaries"
- Supports spatial indexing with GIST indexes for performance
- **Important**: This is the only application table that uses PostGIS geometry - other tables use text or float coordinates

**Design Rationale**: Campus-based delivery zones enable efficient order routing, driver assignment, and delivery fee calculations based on geographic boundaries. The PostGIS geometry type allows for complex polygon shapes representing campus areas and enables spatial operations for determining which restaurants and delivery locations fall within each campus zone.

**Spatial Operations:**
- `ST_Contains(campus.geom, restaurant.location)` - Check if restaurant is within campus
- `ST_Intersects(campus.geom, delivery_point)` - Check if delivery point is within campus
- `ST_Area(campus.geom)` - Calculate campus area for delivery zone management

### Spatial Reference Systems Table

Standard PostGIS system table for spatial reference systems:

```sql
create table if not exists public.spatial_ref_sys (
  srid int4 primary key,
  auth_name varchar(256),
  auth_srid int4,
  srtext varchar(2048),
  proj4text varchar(2048)
);
```

**Fields:**
- `srid`: Spatial reference system identifier (primary key)
- `auth_name`: Authority name (e.g., 'EPSG', 'ESRI')
- `auth_srid`: Authority's spatial reference system identifier
- `srtext`: Well-known text (WKT) representation of the coordinate system
- `proj4text`: PROJ.4 string representation for coordinate transformations

**Purpose:**
This is a PostGIS system table that contains definitions of all spatial reference systems (coordinate systems) used in the database. It's automatically created and populated when PostGIS is installed.

**Common SRIDs:**
- **4326**: WGS84 (World Geodetic System 1984) - Standard GPS coordinates (lat/lon)
- **3857**: Web Mercator - Used by web mapping services like Google Maps
- **4269**: NAD83 - North American Datum 1983
- **2154**: RGF93 / Lambert-93 - French coordinate system

**Usage:**
- Referenced by geometry columns to define their coordinate system
- Used by PostGIS functions like `ST_Transform()` for coordinate system conversions
- Essential for accurate spatial calculations and map projections
- Automatically managed by PostGIS - do not modify manually

**Important Notes:**
- This is a PostGIS system table, not an application table
- Contains global metadata for all spatial reference systems
- Required for PostGIS to function properly
- Should not be modified directly by application code

## Custom Types

### User Role Enum

```sql
create type user_role as enum ('customer', 'driver', 'admin');
```

### Order Status Enum

```sql
create type order_status as enum ('pending', 'accepted', 'preparing', 'delivering', 'completed', 'canceled');
```

**Design Rationale**: The order status workflow includes an explicit "accepted" state to allow restaurants to confirm orders before preparation begins, providing better order management and customer communication.

## Automatic Timestamp Management

### Update Trigger Function

A PostgreSQL function automatically updates the `updated_at` timestamp:

```sql
create or replace function public.set_updated_at() returns trigger
language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end $$;
```

### Triggers

Triggers are applied to all tables to maintain `updated_at` timestamps:

```sql
-- Users trigger
drop trigger if exists trg_users_updated_at on public.users;
create trigger trg_users_updated_at before update on public.users
for each row execute function public.set_updated_at();

-- Restaurants trigger
drop trigger if exists trg_restaurants_updated_at on public.restaurants;
create trigger trg_restaurants_updated_at before update on public.restaurants
for each row execute function public.set_updated_at();

-- Menus trigger
drop trigger if exists trg_menus_updated_at on public.menus;
create trigger trg_menus_updated_at before update on public.menus
for each row execute function public.set_updated_at();

-- Menu items trigger
drop trigger if exists trg_menu_items_updated_at on public.menu_items;
create trigger trg_menu_items_updated_at before update on public.menu_items
for each row execute function public.set_updated_at();

-- Carts trigger
drop trigger if exists trg_carts_updated_at on public.carts;
create trigger trg_carts_updated_at before update on public.carts
for each row execute function public.set_updated_at();

-- Cart items trigger
drop trigger if exists trg_cart_items_updated_at on public.cart_items;
create trigger trg_cart_items_updated_at before update on public.cart_items
for each row execute function public.set_updated_at();

-- Carts items trigger
drop trigger if exists trg_carts_items_updated_at on public.carts_items;
create trigger trg_carts_items_updated_at before update on public.carts_items
for each row execute function public.set_updated_at();

-- Orders trigger
drop trigger if exists trg_orders_updated_at on public.orders;
create trigger trg_orders_updated_at before update on public.orders
for each row execute function public.set_updated_at();

-- Messages trigger
drop trigger if exists trg_messages_updated_at on public.messages;
create trigger trg_messages_updated_at before update on public.messages
for each row execute function public.set_updated_at();
```

## Database Indexes

Performance optimization indexes for common queries:

**Index Types Used:**
- **Regular B-tree indexes**: For standard columns (email, status, timestamps, etc.)
- **Composite indexes**: For multi-column queries (lat, lon coordinates)
- **PostGIS GIST indexes**: For spatial geometry columns (campuses.geom only)

```sql
-- User indexes
create index if not exists idx_users_email on public.users (email);
create index if not exists idx_users_role on public.users (role);

-- Restaurant indexes
create index if not exists idx_restaurants_name on public.restaurants (name);

-- Menu item indexes
create index if not exists idx_menu_items_name on public.menu_items (name);
create index if not exists idx_menu_items_category on public.menu_items (category);
create index if not exists idx_menu_items_menu_id on public.menu_items (menu_id);

-- Cart indexes
create index if not exists idx_carts_user_id on public.carts (user_id);
create index if not exists idx_carts_restaurant_id on public.carts (restaurant_id);
create index if not exists idx_cart_items_user_id on public.cart_items (user_id);
create index if not exists idx_cart_items_menu_item_id on public.cart_items (menu_item_id);
create index if not exists idx_carts_items_cart_id on public.carts_items (cart_id);
create index if not exists idx_carts_items_menu_item_id on public.carts_items (menu_item_id);

-- Order indexes
create index if not exists idx_orders_user_id on public.orders (user_id);
create index if not exists idx_orders_driver_id on public.orders (driver_id);
create index if not exists idx_orders_restaurant_id on public.orders (restaurant_id);
create index if not exists idx_orders_status on public.orders (status);
create index if not exists idx_orders_created_at on public.orders (created_at);
create index if not exists idx_orders_location on public.orders (lat, lon);
create index if not exists idx_order_items_order_id on public.order_items (order_id);
create index if not exists idx_order_items_menu_item_id on public.order_items (menu_item_id);

-- Message indexes
create index if not exists idx_messages_order_id on public.messages (order_id);
create index if not exists idx_messages_sender_id on public.messages (sender_id);
create index if not exists idx_messages_created_at on public.messages (created_at);

-- Driver approval indexes
create index if not exists idx_driver_approvals_is_approved on public.driver_approvals (is_approved);

-- Campus indexes (PostGIS spatial indexes)
create index if not exists idx_campuses_geom on public.campuses using gist (geom);
```

## Table Relationships

### Database Schema Diagram

![Database Schema](/images/schemaImageComp.png)

### Relationship Diagram

```
Users (1) ←→ (0..1) Driver Approvals
Users (1) ←→ (Many) Carts
Users (1) ←→ (Many) Cart Items (Direct)
Users (1) ←→ (Many) Orders (as customer)
Users (1) ←→ (Many) Orders (as driver)
Users (1) ←→ (Many) Messages (as sender)

Restaurants (1) ←→ (1) Menus (1) ←→ (Many) Menu Items
Restaurants (1) ←→ (Many) Carts
Restaurants (1) ←→ (Many) Orders

Carts (1) ←→ (Many) Carts Items
Carts Items (Many) ←→ (1) Menu Items

Orders (1) ←→ (Many) Order Items
Orders (1) ←→ (Many) Messages
Order Items (Many) ←→ (1) Menu Items

Campuses (1) ←→ (Many) Restaurants (spatial relationship)
```

### Relationship Details

#### User Relationships

1. **User → Driver Approval**: One-to-zero-or-one relationship
   - Each user can have at most one driver approval record
   - Driver approval is automatically deleted when user is deleted (cascade)

2. **User → Carts**: One-to-many relationship
   - Each user can have multiple carts (one per restaurant)
   - Carts are automatically deleted when user is deleted (cascade)

3. **User → Cart Items (Direct)**: One-to-many relationship
   - Each user can have multiple direct cart items
   - Cart items are automatically deleted when user is deleted (cascade)

4. **User → Orders (as Customer)**: One-to-many relationship
   - Each user can place multiple orders
   - Orders are automatically deleted when user is deleted (cascade)

5. **User → Orders (as Driver)**: One-to-many relationship
   - Each user can deliver multiple orders
   - Driver reference is set to null when user is deleted (set null)

6. **User → Messages (as Sender)**: One-to-many relationship
   - Each user can send multiple messages
   - Messages are automatically deleted when user is deleted (cascade)

#### Restaurant Relationships

7. **Restaurant → Menu**: One-to-one relationship
   - Each restaurant has exactly one menu
   - Menu is automatically deleted when restaurant is deleted (cascade)

8. **Restaurant → Carts**: One-to-many relationship
   - Each restaurant can have multiple user carts
   - Carts are automatically deleted when restaurant is deleted (cascade)

9. **Restaurant → Orders**: One-to-many relationship
   - Each restaurant can receive multiple orders
   - Orders are automatically deleted when restaurant is deleted (cascade)

#### Menu Relationships

10. **Menu → Menu Items**: One-to-many relationship
    - Each menu can have multiple menu items
    - Menu items are automatically deleted when menu is deleted (cascade)

#### Cart Relationships

11. **Cart → Carts Items**: One-to-many relationship
    - Each cart can contain multiple items
    - Cart items are automatically deleted when cart is deleted (cascade)

12. **Carts Items → Menu Items**: Many-to-one relationship
    - Each cart item references one menu item
    - Cart items are automatically deleted when menu item is deleted (cascade)

13. **Cart Items (Direct) → Menu Items**: Many-to-one relationship
    - Each direct cart item references one menu item
    - Cart items are automatically deleted when menu item is deleted (cascade)

#### Order Relationships

14. **Order → Order Items**: One-to-many relationship
    - Each order can contain multiple items
    - Order items are automatically deleted when order is deleted (cascade)

15. **Order → Messages**: One-to-many relationship
    - Each order can have multiple messages
    - Messages are automatically deleted when order is deleted (cascade)

16. **Order Items → Menu Items**: Many-to-one relationship
    - Each order item references one menu item
    - Order items are automatically deleted when menu item is deleted (cascade)

## Data Operations

### User Management

#### Creating a New User
When a new user is created:
1. User record is inserted with UUID from auth.users
2. Role defaults to 'customer' if not specified
3. Timestamps are automatically set
4. User can immediately start using the system

#### Driver Approval Process
When a user applies to become a driver:
1. Driver approval record is created with `is_approved = false`
2. Admin can later update `is_approved = true` and set `approved_at`
3. Only approved drivers can be assigned to orders

### Restaurant Management

#### Adding a New Restaurant
When a new restaurant is created:
1. Restaurant record is inserted with auto-generated UUID
2. Location is stored as PostGIS geometry
3. Timestamps are automatically set
4. A corresponding menu should be created (enforced by application logic)

#### Adding Menu Items
When menu items are added:
1. Item is linked to existing menu via `menu_id`
2. Price validation ensures positive values
3. Category defaults to 'General' if not specified
4. Timestamps are automatically set

### Cart Operations

#### Adding Items to Cart (Direct Method)
When using the direct cart_items table:
1. Item is linked directly to user via `user_id`
2. Quantity defaults to 1 if not specified
3. Multiple items from different restaurants can be in the same cart

#### Adding Items to Cart (Normalized Method)
When using the carts and carts_items tables:
1. Create or retrieve cart for user-restaurant combination
2. Add item to cart via `cart_id`
3. Special notes can be added for individual items
4. One cart per user per restaurant

### Order Processing

#### Creating an Order
When a customer places an order:
1. Order record is created with customer and restaurant references
2. Delivery coordinates (lat/lon) and special instructions are stored
3. Status is set to 'pending'
4. Pricing is calculated (subtotal, delivery fee, total)
5. Order items are created with denormalized menu item data

#### Order Status Updates
Order status progression:
1. **pending**: Order received, awaiting restaurant confirmation
2. **preparing**: Restaurant is preparing the order
3. **delivering**: Driver has picked up the order
4. **completed**: Order has been delivered to customer
5. **cancelled**: Order was cancelled
6. **accepted**: Order was approved

#### Driver Assignment
When assigning a driver to an order:
1. Driver must be approved (`driver_approvals.is_approved = true`)
2. Driver reference is set in orders table
3. Order status can be updated to 'delivering'

### Message Operations

#### Sending Messages
When users send messages regarding orders:
1. Message record is created with order and sender references
2. Content is stored as text
3. Created timestamp is automatically set
4. Read timestamp is initially null

#### Reading Messages
When messages are read:
1. Read timestamp is updated to current time
2. Message status can be tracked for notification purposes
3. Messages are ordered by creation time for chronological display

### Spatial Operations

#### PostGIS-Based Operations (Campus Management)
When managing delivery zones using PostGIS:
1. Campus boundaries are defined using PostGIS `geometry` data type in the `campuses` table
2. PostGIS functions like `ST_Contains()` can determine which campus contains a given point
3. Spatial queries can find restaurants within campus boundaries using PostGIS functions
4. Complex polygon operations are supported for campus boundary management
5. **Note**: Only the `campuses` table uses PostGIS geometry - other tables use different approaches

#### Coordinate-Based Operations (Order & Restaurant Management)
When managing order and restaurant locations using coordinates:
1. **Restaurants**: Use text-based location descriptions (not PostGIS geometry)
2. **Orders**: Use float coordinates (lat/lon) for delivery locations
3. Distance calculations between restaurants and delivery points use standard mathematical formulas
4. Driver assignment can be optimized based on coordinate proximity calculations
5. **Note**: These operations do NOT use PostGIS functions - they use standard coordinate mathematics

#### Hybrid Spatial Operations
When combining PostGIS and coordinate-based data:
1. Convert coordinates to PostGIS points for spatial queries: `ST_Point(lon, lat)`
2. Use PostGIS functions to check if delivery points fall within campus boundaries
3. Combine campus-based delivery zones with coordinate-based distance calculations

### Deleting Operations

**Cascade Deletion Behavior:**
- Deleting a user → Deletes driver approval, carts, cart items, orders, and messages
- Deleting a restaurant → Deletes menu, menu items, carts, and orders
- Deleting a menu → Deletes all associated menu items
- Deleting a menu item → Deletes cart items and order items (with cascade)
- Deleting an order → Deletes all associated order items and messages
- Deleting a cart → Deletes all associated cart items

**Set Null Behavior:**
- Deleting a driver user → Sets `orders.driver_id` to null (preserves order history)

**Design Rationale**: Using set-null for driver references preserves order history for accounting and customer service purposes, while cascade deletes maintain referential integrity for dependent data like cart items.

### Update Operations

**Automatic Timestamp Updates:**
- Any update to any table with `updated_at` field automatically updates the timestamp
- Triggers ensure consistency across all tables
- Manual timestamp updates are not recommended

**Data Integrity:**
- Foreign key constraints prevent orphaned records
- Enum types ensure valid status and role values
- Spatial data validation through PostGIS functions

## Best Practices

### Data Integrity
- Use UUIDs for all primary keys to avoid conflicts
- Implement proper foreign key constraints with appropriate cascade behaviors
- Use cascade deletes to maintain referential integrity
- Use enum types for status and role fields to ensure data consistency
- Denormalize critical order data (name, price) to preserve historical accuracy

### Performance
- Indexes on frequently queried fields (email, role, status, created_at)
- Use GIST indexes for spatial data (location, geometry)
- Index foreign key relationships for efficient joins
- Use timestamptz for timezone-aware timestamps
- Consider partitioning for large datasets (orders, order_items)

### Spatial Data Management
- Use PostGIS geometry types for campus boundaries and spatial reference systems
- Store order delivery coordinates as float values for distance calculations
- Implement spatial indexes (GIST) for campus geometry queries
- Validate spatial data using PostGIS functions
- Consider coordinate system consistency across all spatial data

### PostGIS System Table Management
- **Never modify PostGIS system tables directly** (`geometry_columns`, `geography_columns`, `spatial_ref_sys`)
- **Let PostGIS manage system tables automatically** when creating/dropping spatial columns
- **Use proper SRID specifications** when creating geometry columns (e.g., `geometry(POINT, 4326)`)
- **Monitor system table integrity** using PostGIS functions like `Populate_Geometry_Columns()`
- **Backup system tables** as part of database backup procedures
- **Understand the difference** between application tables (like `campuses`) and PostGIS system tables

### Cart Management
- Choose between direct (cart_items) or normalized (carts + carts_items) approach based on requirements
- Direct approach allows multi-restaurant carts
- Normalized approach provides better data organization and restaurant-specific carts
- Consider implementing cart expiration for abandoned carts

### Order Management
- Always denormalize menu item data in order_items for historical accuracy
- Implement proper order status workflow
- Use soft deletes for orders to maintain audit trail
- Consider implementing order versioning for complex modifications
- Store delivery coordinates as lat/lon for precise location tracking

### Message Management
- Implement real-time message delivery for order communication
- Track message read status for notification purposes
- Order messages chronologically for clear conversation flow
- Consider implementing message threading for complex discussions
- Implement proper message retention policies for data management

### User Management
- Integrate with external authentication system (auth.users)
- Implement proper role-based access control
- Use driver approval workflow for security
- Maintain audit trail for user role changes

### Security
- Use `pgcrypto` extension for secure UUID generation
- Implement row-level security for multi-tenant scenarios
- Validate input data at application level
- Use parameterized queries to prevent SQL injection
- Implement proper authentication and authorization checks

### Monitoring and Maintenance
- Monitor database performance with query analysis
- Regular maintenance of spatial indexes
- Implement proper backup strategies for spatial data
- Monitor cascade delete performance for large datasets

### PostGIS Troubleshooting

#### Common Issues and Solutions

**"Extra Tables" Appearing in Database:**
- These are PostGIS system tables (`geometry_columns`, `geography_columns`, `spatial_ref_sys`, etc.)
- They are **NOT duplicates** of your application tables
- They are **required** for PostGIS to function properly
- **Do not delete** these tables as they contain essential metadata

**Geometry Column Not Recognized:**
- Ensure PostGIS extension is properly installed: `CREATE EXTENSION IF NOT EXISTS postgis;`
- Use `Populate_Geometry_Columns()` to register existing geometry columns
- Check that geometry columns have proper SRID specifications

**Spatial Queries Not Working:**
- Verify PostGIS functions are available: `SELECT PostGIS_Version();`
- Check that spatial indexes (GIST) are created on geometry columns
- Ensure coordinate systems are consistent across related tables

**Performance Issues with Spatial Data:**
- Create GIST indexes on geometry columns: `CREATE INDEX idx_geom ON table USING GIST (geom);`
- Use spatial bounding box queries when possible
- Consider spatial partitioning for large datasets

#### PostGIS System Table Maintenance

**Checking System Table Integrity:**
```sql
-- Check geometry columns registration
SELECT * FROM geometry_columns;

-- Check spatial reference systems
SELECT srid, auth_name, auth_srid FROM spatial_ref_sys WHERE srid = 4326;

-- Verify PostGIS installation
SELECT PostGIS_Version();
```

**Backup Considerations:**
- Always include PostGIS system tables in database backups
- System tables are small but critical for spatial functionality
- Test spatial functionality after database restores